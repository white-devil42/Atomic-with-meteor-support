/*
 * This file is part of the atomic client distribution.
 * Copyright (c) 2021-2021 0x150.
 */

package me.zeroX150.atomic.feature.module.impl.exploit;

import me.zeroX150.atomic.Atomic;
import me.zeroX150.atomic.feature.gui.notifications.Notification;
import me.zeroX150.atomic.feature.module.Module;
import me.zeroX150.atomic.feature.module.ModuleType;
import me.zeroX150.atomic.feature.module.config.BooleanValue;
import me.zeroX150.atomic.feature.module.config.MultiValue;
import me.zeroX150.atomic.feature.module.config.SliderValue;
import me.zeroX150.atomic.feature.module.impl.world.XRAY;
import me.zeroX150.atomic.helper.render.Renderer;
import me.zeroX150.atomic.helper.util.Queue;
import me.zeroX150.atomic.helper.util.Utils;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

public class AntiAntiXray extends Module {

    final SliderValue     range         = (SliderValue) this.config.create("Range", 16, 2, 64, 0).description("The range to scan ores in");
    final SliderValue     skipDistance  = (SliderValue) this.config.create("Skip distance", 2, 0, 6, 1).description("The distance around a ore to skip scans in");
    final MultiValue      mode          = (MultiValue) this.config.create("Mode", "Ores", "Ores", "Stone", "Diamond", "Redstone", "Iron", "Netherite", "Everything").description("The mode");
    final SliderValue     blocksPerTick = (SliderValue) this.config.create("Blocks per tick", 10, 1, 20, 0).description("The amount of blocks scanned per tick");
    final SliderValue     delay         = (SliderValue) this.config.create("Delay", 0, 0, 20, 0).description("The delay between scan iterations");
    final BooleanValue    showAura      = (BooleanValue) this.config.create("Show aura", false).description("Shows a nice small effect around scanned blocks (VERY performance intensive)");
    //    final BooleanValue    mineBaritone  = (BooleanValue) this.config.create("Baritone automine", false).description("Automatically mines the remaining ores with baritone");
    final Queue<BlockPos> toScan        = new Queue<>();
    final List<BlockPos>  renders       = new ArrayList<>();
    final List<BlockPos>  visitsAfter   = new ArrayList<>();
    final SliderValue     customYSize   = (SliderValue) this.config.create("Custom Y size", -1, -1, 255, 0).description("Custom Y size of scanner box (-1 to disable)");
    List<BlockPos> permanentToScan = new ArrayList<>();
    Vec3d          startPos;
    int            scanned         = 0;
    int            delayPassed     = 0;
    BlockPos       latestGoal      = null;

    public AntiAntiXray() {
        super("AntiAntiXray", "fuck you antixray i hope you choke on garlic", ModuleType.EXPLOIT);
        this.config.createPropGroup("Rendering", showAura);
        this.config.createPropGroup("Scanner", range, skipDistance, mode, blocksPerTick, delay);
        //this.config.createPropGroup("Post", mineBaritone);
    }

    boolean isBlockValid(Block b) {
        return switch (mode.getValue().toLowerCase()) {
            case "ores" -> XRAY.blocks.contains(b); // ores mode
            case "stone" -> b == Blocks.STONE; // stone mode
            case "diamond" -> b == Blocks.DIAMOND_ORE; // diamond ore mode
            case "redstone" -> b == Blocks.REDSTONE_ORE; // redstone ore mode
            case "iron" -> b == Blocks.IRON_ORE; // iron ore mode
            case "netherite" -> b == Blocks.ANCIENT_DEBRIS; // ancient debris mode
            default -> true; // everything mode
        };
    }

    @Override public void tick() {
        if (Atomic.client.player == null || Atomic.client.getNetworkHandler() == null) {
            return;
        }
        if (toScan.getQueue().size() == 0) {
            Notification.create(5000, "AntiAntiXray", "Done scanning ores!");
            toggle();
            return;
        }
        if (delayPassed > delay.getValue()) {
            delayPassed = 0;
        } else {
            delayPassed++;
            return;
        }
        renders.clear();
        for (int i = 0; i < blocksPerTick.getValue(); i++) {
            if (toScan.getQueue().size() == 0) {
                break;
            }
            BlockPos current = toScan.poll();
            renders.add(current);
            scanned++;

            PlayerActionC2SPacket p = new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, current, Direction.DOWN);
            Atomic.client.getNetworkHandler().sendPacket(p);
        }
    }

    @Override public void enable() {
        if (Atomic.client.player == null || Atomic.client.world == null) {
            return;
        }
        toScan.getQueue().clear();
        scanned = 0;
        startPos = Atomic.client.player.getPos();
        BlockPos ppos = Atomic.client.player.getBlockPos();
        Vec3d lastPos = Vec3d.ZERO;
        int rangeMid = (int) (range.getValue() / 2);
        int ry = customYSize.getValue() == -1 ? rangeMid : (int) (customYSize.getValue() / 2);
        for (int y = ry; y > -ry; y--) {
            for (int x = -rangeMid; x < rangeMid; x++) {
                for (int z = -rangeMid; z < rangeMid; z++) {
                    BlockPos current = ppos.add(x, y, z);
                    BlockState bs = Atomic.client.world.getBlockState(current);
                    Vec3d currentPos = new Vec3d(current.getX(), current.getY(), current.getZ());
                    if (!bs.isAir() && lastPos.distanceTo(currentPos) >= skipDistance.getValue()) {
                        if (isBlockValid(bs.getBlock())) {
                            toScan.add(current);
                            lastPos = currentPos;
                        }
                    }
                }
            }
        }
        permanentToScan = new ArrayList<>(toScan.getQueue());
    }

    @Override public void disable() {
        visitsAfter.clear();
        latestGoal = null;
    }

    @Override public String getContext() {
        return "[" + scanned + "S;" + toScan.getQueue().size() + "R]";
    }

    @Override public void onWorldRender(MatrixStack matrices) {
        for (BlockPos latestScan : renders.toArray(new BlockPos[0])) {
            Renderer.R3D.renderFilled(new Vec3d(latestScan.getX(), latestScan.getY(), latestScan.getZ()), new Vec3d(1, 1, 1), Utils.getCurrentRGB(), matrices);
        }
        double mid = this.range.getValue() / 2;
        Vec3d s = new Vec3d(mid, mid, mid);
        Vec3d ppOrigin = startPos;
        Vec3d boxOrigin = ppOrigin.subtract(s);
        Renderer.R3D.renderOutline(boxOrigin, s.multiply(2), Utils.getCurrentRGB(), matrices);

        if (customYSize.getValue() != -1) {
            Vec3d sub = new Vec3d(mid, customYSize.getValue() / 2d, mid);
            Renderer.R3D.renderOutline(ppOrigin.subtract(sub), sub.multiply(2), Color.CYAN, matrices);
        }

        if (latestGoal != null) {
            Renderer.R3D.line(Renderer.R3D.getCrosshairVector(), new Vec3d(latestGoal.getX(), latestGoal.getY(), latestGoal.getZ()).add(0.5, 0.5, 0.5), Color.CYAN, matrices);
        }

        if (renders.size() == 0 || !showAura.getValue()) {
            return;
        }
        double maxDist = 5;
        for (BlockPos bp : permanentToScan) {
            Vec3d vv = new Vec3d(bp.getX(), bp.getY(), bp.getZ());
            double d = 0;
            int i = 0;
            // vv.distanceTo(latestv3) / maxDist
            for (BlockPos render : renders) {
                Vec3d e = new Vec3d(render.getX(), render.getY(), render.getZ());
                double ee = vv.distanceTo(e) / maxDist;
                if (ee > 1) {
                    continue;
                }
                d += ee;
                i++;
            }
            if (i == 0) {
                continue;
            }
            d /= i;
            d = Math.abs(1 - d);
            Color c = Color.getHSBColor((float) d, 0.6f, 1f);
            c = Renderer.Util.modify(c, -1, -1, -1, (int) Math.floor(d * 255d));
            Renderer.R3D.renderOutline(vv, new Vec3d(1, 1, 1), c, matrices);
        }
    }

    @Override public void onHudRender() {

    }
}

